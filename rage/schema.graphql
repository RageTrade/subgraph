# ----------------------
# Rage Perpswap Subgraph
#-----------------------

type Owner @entity {
  "address of the owner"
  id: ID!
  "list of accounts"
  accounts: [Account!]! @derivedFrom(field: "owner")
}

"""
new account creation
"""
type Account @entity {
  id: ID! # the accountNo
  "timestamp of the token position change"
  timestamp: BigInt!
  "ownerAddress wallet address of account owner"
  owner: Owner!
  vQuoteBalance: BigDecimal!
  marginBalance: BigDecimal!

  margin: [Collateral!]! @derivedFrom(field: "account")
  tokenPositions: [TokenPosition!]! @derivedFrom(field: "account")

  tokenPositionChangeEntriesCount: BigInt!

  tokenPositionChangeEntries: [TokenPositionChangeEntry!]!
    @derivedFrom(field: "account")
  marginChangeEntriesCount: BigInt!
  marginChangeEntries: [MarginChangeEntry!]! @derivedFrom(field: "account")

  liquidateToken: [Collateral!]! @derivedFrom(field: "account")
  liquidateRangePosition: [Collateral!]! @derivedFrom(field: "account")
  liquidityPosition: [LiquidityPosition!]! @derivedFrom(field: "account")
  liquidityPositionEntry: [LiquidityPositionEntry!]!
    @derivedFrom(field: "account")
}

type VQuote @entity {
  id: ID! # address
  symbol: String!
  name: String!
  decimals: BigInt!
}

"""
Data help by the protocol
"""
type Protocol @entity {
  id: ID!

  tvlUSDC: BigDecimal!

  "fee earned by lps"
  lpFees: BigDecimal!

  "fee earned by the protocol"
  protocolFees: BigDecimal!

  vQuote: VQuote!
}

"""
deposit/withdraw of margin
"""
type Collateral @entity {
  id: ID! # accountNo - rTokenAddress
  "timestamp of the token position change"
  timestamp: BigInt!
  " accountNo serial number of the account"
  account: Account!
  " amount of tokens deposited"
  amount: BigInt!
  "total realized profit of the account"
  totalProfit: BigInt
  "margin ratio (total collateral) / SUM(all positions)"
  marginRatio: BigInt
}

enum Side {
  long
  short
}

"""
funding rate
"""
type FundingPaymentRealizedEntry @entity {
  id: ID!

  fundingRate: BigDecimal!

  "long or short"
  side: Side!

  "token Position on vToken"
  tokenPosition: TokenPosition!

  "timestamp of the funding rate"
  timestamp: BigInt!

  transactionHash: Bytes!

  "amount of base token in the funding rate, in settlementToken(USDC)"
  amount: BigDecimal!

  vTokenPosition: BigDecimal!
}

"""
token position change
"""
type TokenPosition @entity {
  id: ID! # accountNo - vToken - timestamp
  "accountNo serial number of the account"
  account: Account!
  "vToken address of token whose position was taken"
  rageTradePool: RageTradePool!
  "tokenAmountOut amount of tokens that account received (positive) or paid (negative)"
  netPosition: BigDecimal!

  liquidationPrice: BigDecimal!

  fundingPaymentRealizedEntriesCount: BigInt!

  fundingPaymentRealizedEntries: [FundingPaymentRealizedEntry!]!
    @derivedFrom(field: "tokenPosition")

  "array of id of the token position change entries, that are open positions"
  openPositionEntries: [String!]!

  lastTokenPositionChangeEntry: TokenPositionChangeEntry!

  tokenPositionLiquidatedEntriesCount: BigInt!
  tokenPositionLiquidatedEntries: [TokenPositionLiquidatedEntry!]!
    @derivedFrom(field: "tokenPosition")

  totalRealizedFundingPaymentAmount: BigDecimal!

  sumAX128CheckPoint: BigInt!

  buyVQuoteAmount: BigDecimal!
  buyVTokenAmount: BigDecimal!

  sellVQuoteAmount: BigDecimal!
  sellVTokenAmount: BigDecimal!

  entryValue: BigDecimal!
  entryPrice: BigDecimal! # entryPrice = abs(entryValue / netPosition)
}

enum MarginTransactionType {
  deposit
  withdraw
}

"""
token position change
"""
type MarginChangeEntry @entity {
  id: ID! # accountNo - vToken - timestamp
  "timestamp of the token position change"
  timestamp: BigInt!

  transactionHash: Bytes!

  "accountNo serial number of the account"
  account: Account!

  "settlement token"
  amount: BigDecimal!

  transactionType: MarginTransactionType!
}

"""
token position change
"""
type TokenPositionChangeEntry @entity {
  id: ID! # accountNo - vToken - timestamp
  "timestamp of the token position change"
  timestamp: BigInt!

  transactionHash: Bytes!

  "long or short"
  side: Side!

  "accountNo serial number of the account"
  account: Account!
  "rageTradePool position was taken"
  rageTradePool: RageTradePool!
  "tokenAmountOut amount of tokens that account received (positive) or paid (negative)"
  vTokenAmountOut: BigDecimal!
  "baseAmountOut amount of base tokens that account received (positive) or paid (negative)"
  vQuoteAmountOut: BigDecimal!

  vTokenQuantity: BigDecimal!

  entryPrice: BigDecimal!
  executionPrice: BigDecimal!
  startPrice: BigDecimal!
  endPrice: BigDecimal!
}

"""
token liquidation
"""
type TokenPositionLiquidatedEntry @entity {
  id: ID! # accountNo - vToken - timestamp
  "timestamp of the token position change"
  timestamp: BigInt!
  transactionHash: Bytes!

  "accountNo serial number of the account"
  account: Account!

  tokenPosition: TokenPosition!

  "liquidatorAccountId account which performed the liquidation"
  liquidatorAccountId: BigInt!

  "vToken address of token for whose position was liquidated"
  rageTradePool: RageTradePool!

  side: Side!

  "vQuote from most recent token position changes event"
  amountClosed: BigDecimal!

  "execution price for most recent token position changes event"
  liquidationPrice: BigDecimal!

  feeKeeper: BigDecimal!

  feeInsuranceFund: BigDecimal!

  accountMarketValueFinal: BigDecimal!
}

"""
range liquidation
"""
type LiquidateRangePosition @entity {
  id: ID! # accountNo - keeperAddress - timestamp
  "timestamp of the token position change"
  timestamp: BigInt!
  "accountNo serial number of the account"
  account: Account!
  "keeperAddress address of keeper who performed the liquidation"
  keeperAddress: Bytes!
  "liquidationFee total liquidation fee charged to the account"
  liquidationFee: BigInt!
  "keeperFee total liquidaiton fee paid to the keeper (positive only)"
  keeperFee: BigInt!
  "insuranceFundFee total liquidaiton fee paid to the insurance fund (can be negative in case the account is not enought to cover the fee)"
  insuranceFundFee: BigInt!
}

"""
limit order types
"""
enum TokenStatus {
  NONE
  LOWER_LIMIT
  UPPER_LIMIT
}

"""
denotes net token position change due to liquidity add/remove, funding
"""
type LiquidityPosition @entity {
  id: ID! # accountNo - vToken - timestamp
  "timestamp of the token position change"
  timestamp: BigInt!
  "accountNo serial number of the account"
  account: Account!
  "vToken address of token whose position was taken"
  vToken: Bytes!
  "tickLower lower tick of the range updated"
  tickLower: Int!
  "tickUpper upper tick of the range updated"
  tickUpper: Int!
  "tokenAmountOut amount of tokens that account received (positive) or paid (negative)"
  tokenAmountOut: BigInt!
  "liquidityDelta change in liquidity value"
  liquidityDelta: BigInt
  "limitOrderType the type of range position"
  limitOrderType: TokenStatus
  "funding payment for a range / token position received"
  fundingPayment: BigInt
  "fee payment for a range / token position"
  feePayment: BigInt
  "keeperAddress address of keeper who performed the liquidation"
  keeperAddress: Bytes
  "liquidationFee Bytes liquidation fee charged to the account"
  liquidationFee: BigDecimal
  "keeperFee total liquidaiton fee paid to the keeper (positive only)"
  keeperFee: BigInt
  "insuranceFundFee total liquidaiton fee paid to the insurance fund (can be negative in case the account is not enought to cover the fee)"
  insuranceFundFee: BigInt
}

"""
denotes historical token position changes due to liquidity add/remove, funding
"""
type LiquidityPositionEntry @entity {
  id: ID! # accountNo - vToken - timestamp
  "timestamp of the token position change"
  timestamp: BigInt!
  "accountNo serial number of the account"
  account: Account!
  "vToken address of token whose position was taken"
  vToken: Bytes!
  "tickLower lower tick of the range updated"
  tickLower: Int!
  "tickUpper upper tick of the range updated"
  tickUpper: Int!
  "tokenAmountOut amount of tokens that account received (positive) or paid (negative)"
  tokenAmountOut: BigInt!
  "liquidityDelta change in liquidity value"
  liquidityDelta: BigInt
  "limitOrderType the type of range position"
  limitOrderType: TokenStatus
  "funding payment for a range / token position received"
  fundingPayment: BigInt
  "fee payment for a range / token position"
  feePayment: BigInt
  "liquidationFee Bytes liquidation fee charged to the account"
  liquidationFee: BigDecimal
  "keeperFee total liquidaiton fee paid to the keeper (positive only)"
  keeperFee: BigInt
  "insuranceFundFee total liquidaiton fee paid to the insurance fund (can be negative in case the account is not enought to cover the fee)"
  insuranceFundFee: BigInt
}

type RageTradeFactory @entity {
  id: ID! # factory address
  pools: [RageTradePool!]! @derivedFrom(field: "factory")
}

type RageTradePool @entity {
  id: ID! # vToken address
  vToken: VToken!

  vPool: Temp_UniswapV3_Pool!
  vPoolWrapper: VPoolWrapper!

  factory: RageTradeFactory! # links to the factory
  price: BigDecimal!
  tick: BigInt!
  liquidity: BigInt!

  "Total value locked in pool (in vQuote(USDC) tokens)"
  vTotalValueLocked: BigDecimal!
  maintenanceMarginRatioBps: BigDecimal!

  fundingRate: BigDecimal!
  volume24H: BigInt!
  priceChange24H: BigInt!

  sumAX128: BigInt!
  sumBX128: BigInt!
  sumFpX128: BigInt!
  sumFeeX128: BigInt!

  hourData: Collection!
  dayData: Collection!
}

type VToken @entity {
  id: ID! # address
  pool: RageTradePool!

  symbol: String!
  name: String!
  decimals: BigInt!
}

type VPoolWrapper @entity {
  id: ID! # wrapper address
  pool: RageTradePool!
}

type Collection @entity {
  id: ID!
  data: [Candle!]! @derivedFrom(field: "collection")
}

type Candle @entity {
  id: ID!
  collection: Collection!
  periodStartUnix: Int!

  tick: BigInt!

  open: BigDecimal!
  high: BigDecimal!
  low: BigDecimal!
  close: BigDecimal!

  sumAX128: BigInt!
  sumBX128: BigInt!
  sumFpX128: BigInt!
  sumFeeX128: BigInt!

  volumeVToken: BigDecimal!
  volumeUSDC: BigDecimal!
  txCount: BigInt!

  liquidity: BigInt!
}

# -------------------
# Uniswap V3 Subgraph
#--------------------

type UniswapV3Factory @entity {
  # factory address
  id: ID!
  # amount of pools created
  poolCount: BigInt!
  # amoutn of transactions all time
  txCount: BigInt!
  # total volume all time in derived USD
  totalVolumeUSD: BigDecimal!
  # total volume all time in derived ETH
  totalVolumeETH: BigDecimal!
  # total swap fees all time in USD
  totalFeesUSD: BigDecimal!
  # total swap fees all time in USD
  totalFeesETH: BigDecimal!
  # all volume even through less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  # TVL derived in USD
  totalValueLockedUSD: BigDecimal!
  # TVL derived in ETH
  totalValueLockedETH: BigDecimal!
  # TVL derived in USD untracked
  totalValueLockedUSDUntracked: BigDecimal!
  # TVL derived in ETH untracked
  totalValueLockedETHUntracked: BigDecimal!

  # current owner of the factory
  owner: ID!
}

# stores for USD calculations
type Bundle @entity {
  id: ID!
  # price of ETH in usd
  ethPriceUSD: BigDecimal!
}

type UniswapV3Token @entity {
  # token address
  id: ID!
  # token symbol
  symbol: String!
  # token name
  name: String!
  # token decimals
  decimals: BigInt!
  # token total supply
  totalSupply: BigInt!
  # volume in token units
  volume: BigDecimal!
  # volume in derived USD
  volumeUSD: BigDecimal!
  # volume in USD even on pools with less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # transactions across all pools that include this token
  txCount: BigInt!
  # number of pools containing this token
  poolCount: BigInt!
  # liquidity across all pools in token units
  totalValueLocked: BigDecimal!
  # liquidity across all pools in derived USD
  totalValueLockedUSD: BigDecimal!
  # TVL derived in USD untracked
  totalValueLockedUSDUntracked: BigDecimal!
  # derived price in ETH
  derivedETH: BigDecimal!
  # pools token is in that are white listed for USD pricing
  whitelistPools: [UniswapV3Pool!]!
  # derived fields
  tokenDayData: [TokenDayData!]! @derivedFrom(field: "token")
}

type Temp_UniswapV3_Pool @entity {
  # pool address
  id: ID!

  rageTradePool: RageTradePool!
}

type UniswapV3Pool @entity {
  # pool address
  id: ID!
  # creation
  createdAtTimestamp: BigInt!
  # block pool was created at
  createdAtBlockNumber: BigInt!
  # token0
  token0: UniswapV3Token!
  # token1
  token1: UniswapV3Token!
  # fee amount
  feeTier: BigInt!
  # in range liquidity
  liquidity: BigInt!
  # current price tracker
  sqrtPrice: BigInt!
  # token0 per token1
  token0Price: BigDecimal!
  # token1 per token0
  token1Price: BigDecimal!
  # current tick
  tick: BigInt
  # current observation index
  observationIndex: BigInt!
  # all time token0 swapped
  volumeToken0: BigDecimal!
  # all time token1 swapped
  volumeToken1: BigDecimal!
  # all time USD swapped
  volumeUSD: BigDecimal!
  # all time USD swapped, unfiltered for unreliable USD pools
  untrackedVolumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # all time number of transactions
  txCount: BigInt!
  # all time fees collected token0
  collectedFeesToken0: BigDecimal!
  # all time fees collected token1
  collectedFeesToken1: BigDecimal!
  # all time fees collected derived USD
  collectedFeesUSD: BigDecimal!
  # total token 0 across all ticks
  totalValueLockedToken0: BigDecimal!
  # total token 1 across all ticks
  totalValueLockedToken1: BigDecimal!
  # tvl derived ETH
  totalValueLockedETH: BigDecimal!
  # tvl USD
  totalValueLockedUSD: BigDecimal!
  # TVL derived in USD untracked
  totalValueLockedUSDUntracked: BigDecimal!
  # Fields used to help derived relationship
  liquidityProviderCount: BigInt! # used to detect new exchanges
  # hourly snapshots of pool data
  poolHourData: [PoolHourData!]! @derivedFrom(field: "pool")
  # daily snapshots of pool data
  poolDayData: [PoolDayData!]! @derivedFrom(field: "pool")
  # derived fields
  mints: [UniswapV3Mint!]! @derivedFrom(field: "pool")
  burns: [UniswapV3Burn!]! @derivedFrom(field: "pool")
  swaps: [UniswapV3Swap!]! @derivedFrom(field: "pool")
  collects: [UniswapV3Collect!]! @derivedFrom(field: "pool")
  ticks: [UniswapV3Tick!]! @derivedFrom(field: "pool")
}

type UniswapV3Tick @entity {
  # format: <pool address>#<tick index>
  id: ID!
  # pool address
  poolAddress: String
  # tick index
  tickIdx: BigInt!
  # pointer to pool
  pool: UniswapV3Pool!
  # total liquidity pool has as tick lower or upper
  liquidityGross: BigInt!
  # how much liquidity changes when tick crossed
  liquidityNet: BigInt!
  # calculated price of token0 of tick within this pool - constant
  price0: BigDecimal!
  # calculated price of token1 of tick within this pool - constant
  price1: BigDecimal!
  # lifetime volume of token0 with this tick in range
  volumeToken0: BigDecimal!
  # lifetime volume of token1 with this tick in range
  volumeToken1: BigDecimal!
  # lifetime volume in derived USD with this tick in range
  volumeUSD: BigDecimal!
  # lifetime volume in untracked USD with this tick in range
  untrackedVolumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # all time collected fees in token0
  collectedFeesToken0: BigDecimal!
  # all time collected fees in token1
  collectedFeesToken1: BigDecimal!
  # all time collected fees in USD
  collectedFeesUSD: BigDecimal!
  # created time
  createdAtTimestamp: BigInt!
  # created block
  createdAtBlockNumber: BigInt!
  # Fields used to help derived relationship
  liquidityProviderCount: BigInt! # used to detect new exchanges
}

type UniswapV3Transaction @entity {
  # txn hash
  id: ID!
  # block txn was included in
  blockNumber: BigInt!
  # timestamp txn was confirmed
  timestamp: BigInt!
  # gas used during txn execution
  gasUsed: BigInt!
  gasPrice: BigInt!
  # derived values
  mints: [UniswapV3Mint]! @derivedFrom(field: "transaction")
  burns: [UniswapV3Burn]! @derivedFrom(field: "transaction")
  collects: [UniswapV3Collect]! @derivedFrom(field: "transaction")
}

type UniswapV3Mint @entity {
  # transaction hash + "#" + index in mints Transaction array
  id: ID!
  # which txn the mint was included in
  transaction: UniswapV3Transaction!
  # time of txn
  timestamp: BigInt!
  # pool position is within
  pool: UniswapV3Pool!
  # allow indexing by tokens
  token0: UniswapV3Token!
  # allow indexing by tokens
  token1: UniswapV3Token!
  # owner of position where liquidity minted to
  owner: Bytes!
  # the address that minted the liquidity
  sender: Bytes
  # txn origin
  origin: Bytes! # the EOA that initiated the txn
  # amount of liquidity minted
  amount: BigInt!
  # amount of token 0 minted
  amount0: BigDecimal!
  # amount of token 1 minted
  amount1: BigDecimal!
  # derived amount based on available prices of tokens
  amountUSD: BigDecimal
  # lower tick of the position
  tickLower: BigInt!
  # upper tick of the position
  tickUpper: BigInt!
  # order within the txn
  logIndex: BigInt
}

type UniswapV3Burn @entity {
  # transaction hash + "#" + index in mints Transaction array
  id: ID!
  # txn burn was included in
  transaction: UniswapV3Transaction!
  # pool position is within
  pool: UniswapV3Pool!
  # allow indexing by tokens
  token0: UniswapV3Token!
  # allow indexing by tokens
  token1: UniswapV3Token!
  # need this to pull recent txns for specific token or pool
  timestamp: BigInt!
  # owner of position where liquidity was burned
  owner: Bytes
  # txn origin
  origin: Bytes! # the EOA that initiated the txn
  # amouny of liquidity burned
  amount: BigInt!
  # amount of token 0 burned
  amount0: BigDecimal!
  # amount of token 1 burned
  amount1: BigDecimal!
  # derived amount based on available prices of tokens
  amountUSD: BigDecimal
  # lower tick of position
  tickLower: BigInt!
  # upper tick of position
  tickUpper: BigInt!
  # position within the transactions
  logIndex: BigInt
}

type UniswapV3Swap @entity {
  # transaction hash + "#" + index in swaps Transaction array
  id: ID!
  # pointer to transaction
  transaction: UniswapV3Transaction!
  # timestamp of transaction
  timestamp: BigInt!
  # pool swap occured within
  pool: UniswapV3Pool!
  # allow indexing by tokens
  token0: UniswapV3Token!
  # allow indexing by tokens
  token1: UniswapV3Token!
  # sender of the swap
  sender: Bytes!
  # recipient of the swap
  recipient: Bytes!
  # txn origin
  origin: Bytes! # the EOA that initiated the txn
  # delta of token0 swapped
  amount0: BigDecimal!
  # delta of token1 swapped
  amount1: BigDecimal!
  # derived info
  amountUSD: BigDecimal!
  # The sqrt(price) of the pool after the swap, as a Q64.96
  sqrtPriceX96: BigInt!
  # the tick after the swap
  tick: BigInt!
  # index within the txn
  logIndex: BigInt
}

type UniswapV3Collect @entity {
  # transaction hash + "#" + index in collect Transaction array
  id: ID!
  # pointer to txn
  transaction: UniswapV3Transaction!
  # timestamp of event
  timestamp: BigInt!
  # pool collect occured within
  pool: UniswapV3Pool!
  # owner of position collect was performed on
  owner: Bytes
  # amount of token0 collected
  amount0: BigDecimal!
  # amount of token1 collected
  amount1: BigDecimal!
  # derived amount based on available prices of tokens
  amountUSD: BigDecimal
  # lower tick of position
  tickLower: BigInt!
  # uppper tick of position
  tickUpper: BigInt!
  # index within the txn
  logIndex: BigInt
}

type UniswapV3Flash @entity {
  # transaction hash + "-" + index in collect Transaction array
  id: ID!
  # pointer to txn
  transaction: UniswapV3Transaction!
  # timestamp of event
  timestamp: BigInt!
  # pool collect occured within
  pool: UniswapV3Pool!
  # sender of the flash
  sender: Bytes!
  # recipient of the flash
  recipient: Bytes!
  # amount of token0 flashed
  amount0: BigDecimal!
  # amount of token1 flashed
  amount1: BigDecimal!
  # derived amount based on available prices of tokens
  amountUSD: BigDecimal!
  # amount token0 paid for flash
  amount0Paid: BigDecimal!
  # amount token1 paid for flash
  amount1Paid: BigDecimal!
  # index within the txn
  logIndex: BigInt
}

# Data accumulated and condensed into day stats for all of Uniswap
type UniswapDayData @entity {
  # timestamp rounded to current day by dividing by 86400
  id: ID!
  # timestamp rounded to current day by dividing by 86400
  date: Int!
  # total daily volume in Uniswap derived in terms of ETH
  volumeETH: BigDecimal!
  # total daily volume in Uniswap derived in terms of USD
  volumeUSD: BigDecimal!
  # total daily volume in Uniswap derived in terms of USD untracked
  volumeUSDUntracked: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # number of daily transactions
  txCount: BigInt!
  # tvl in terms of USD
  tvlUSD: BigDecimal!
}

# Data accumulated and condensed into day stats for each pool
type PoolDayData @entity {
  # timestamp rounded to current day by dividing by 86400
  id: ID!
  # timestamp rounded to current day by dividing by 86400
  date: Int!
  # pointer to pool
  pool: UniswapV3Pool!
  # in range liquidity at end of period
  liquidity: BigInt!
  # current price tracker at end of period
  sqrtPrice: BigInt!
  # price of token0 - derived from sqrtPrice
  token0Price: BigDecimal!
  # price of token1 - derived from sqrtPrice
  token1Price: BigDecimal!
  # current tick at end of period
  tick: BigInt
  # tvl derived in USD at end of period
  tvlUSD: BigDecimal!
  # volume in token0
  volumeToken0: BigDecimal!
  # volume in token1
  volumeToken1: BigDecimal!
  # volume in USD
  volumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # numebr of transactions during period
  txCount: BigInt!
  # opening price of token0
  open: BigDecimal!
  # high price of token0
  high: BigDecimal!
  # low price of token0
  low: BigDecimal!
  # close price of token0
  close: BigDecimal!
}

# hourly stats tracker for pool
type PoolHourData @entity {
  # format: <pool address>-<timestamp>
  id: ID!
  # unix timestamp for start of hour
  periodStartUnix: Int!
  # pointer to pool
  pool: UniswapV3Pool!
  # in range liquidity at end of period
  liquidity: BigInt!
  # current price tracker at end of period
  sqrtPrice: BigInt!
  # price of token0 - derived from sqrtPrice
  token0Price: BigDecimal!
  # price of token1 - derived from sqrtPrice
  token1Price: BigDecimal!
  # current tick at end of period
  tick: BigInt
  # tvl derived in USD at end of period
  tvlUSD: BigDecimal!
  # volume in token0
  volumeToken0: BigDecimal!
  # volume in token1
  volumeToken1: BigDecimal!
  # volume in USD
  volumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # numebr of transactions during period
  txCount: BigInt!
  # opening price of token0
  open: BigDecimal!
  # high price of token0
  high: BigDecimal!
  # low price of token0
  low: BigDecimal!
  # close price of token0
  close: BigDecimal!
}

type TickHourData @entity {
  # format: <pool address>-<tick index>-<timestamp>
  id: ID!
  # unix timestamp for start of hour
  periodStartUnix: Int!
  # pointer to pool
  pool: UniswapV3Pool!
  # pointer to tick
  tick: UniswapV3Tick!
  # total liquidity pool has as tick lower or upper at end of period
  liquidityGross: BigInt!
  # how much liquidity changes when tick crossed at end of period
  liquidityNet: BigInt!
  # hourly volume of token0 with this tick in range
  volumeToken0: BigDecimal!
  # hourly volume of token1 with this tick in range
  volumeToken1: BigDecimal!
  # hourly volume in derived USD with this tick in range
  volumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
}

# Data accumulated and condensed into day stats for each exchange
# Note: this entity gets saved only if there is a change during the day
type TickDayData @entity {
  # format: <pool address>-<tick index>-<timestamp>
  id: ID!
  # timestamp rounded to current day by dividing by 86400
  date: Int!
  # pointer to pool
  pool: UniswapV3Pool!
  # pointer to tick
  tick: UniswapV3Tick!
  # total liquidity pool has as tick lower or upper at end of period
  liquidityGross: BigInt!
  # how much liquidity changes when tick crossed at end of period
  liquidityNet: BigInt!
  # hourly volume of token0 with this tick in range
  volumeToken0: BigDecimal!
  # hourly volume of token1 with this tick in range
  volumeToken1: BigDecimal!
  # hourly volume in derived USD with this tick in range
  volumeUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
}

type TokenDayData @entity {
  # token address concatendated with date
  id: ID!
  # timestamp rounded to current day by dividing by 86400
  date: Int!
  # pointer to token
  token: UniswapV3Token!
  # volume in token units
  volume: BigDecimal!
  # volume in derived USD
  volumeUSD: BigDecimal!
  # volume in USD even on pools with less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  # liquidity across all pools in token units
  totalValueLocked: BigDecimal!
  # liquidity across all pools in derived USD
  totalValueLockedUSD: BigDecimal!
  # price at end of period in USD
  priceUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # opening price USD
  open: BigDecimal!
  # high price USD
  high: BigDecimal!
  # low price USD
  low: BigDecimal!
  # close price USD
  close: BigDecimal!
}

type TokenHourData @entity {
  # token address concatendated with date
  id: ID!
  # unix timestamp for start of hour
  periodStartUnix: Int!
  # pointer to token
  token: UniswapV3Token!
  # volume in token units
  volume: BigDecimal!
  # volume in derived USD
  volumeUSD: BigDecimal!
  # volume in USD even on pools with less reliable USD values
  untrackedVolumeUSD: BigDecimal!
  # liquidity across all pools in token units
  totalValueLocked: BigDecimal!
  # liquidity across all pools in derived USD
  totalValueLockedUSD: BigDecimal!
  # price at end of period in USD
  priceUSD: BigDecimal!
  # fees in USD
  feesUSD: BigDecimal!
  # opening price USD
  open: BigDecimal!
  # high price USD
  high: BigDecimal!
  # low price USD
  low: BigDecimal!
  # close price USD
  close: BigDecimal!
}
